/*Напишите эффективную программу, находящую все числа длины n являющиеся палиндромами. В комментариях напишите, почему перебор - эффективный*/

#include <iostream>
#include <math.h>

using namespace std;


int main()
{
    int n;
    cin >> n;
    int numsize1 = n - (n/2);
    int numsize2 = n/2;

    for (int j = pow (10.0, numsize1-1); j < pow (10.0, numsize1); j++){
        cout << j;
        for (int i = numsize1-numsize2; i < numsize1; i++){
            cout << int(fmod((j/pow(10.0, i)), 10.0));
        };
        cout << '\n';
    };
    return 0;
}

/*перебор является эффективным, т.к. мы рассматриваем лишь 1/(10^n) возможных n-значных чисел, каждому из которых заведомо соотвествует палиндром,
причём соотвествие однозначно в обе стороны => больше случаев быть не может.*/
